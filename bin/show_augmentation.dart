import 'dart:io';

import 'package:args/args.dart';
import 'package:lsp_client/lsp_client.dart';

const _fileOption = 'file';
const _lineNumbersFlag = 'line-numbers';
const _helpFlag = 'help';
const _verboseFlag = 'verbose';
const _vFlag = 'v';
const _usageError = 64;

Future<void> main(List<String> argv) async {
  final pwd = Directory.current.path;
  final args = _parseArgs(argv);

  final file = File(args.path);
  if (!file.existsSync()) {
    stderr.writeln('File not found: ${args.path}');
    exit(1);
  }

  final rawClient = LspRawClient();

  if (args.verbose) rawClient.addListener(LspRawPrintListener());

  final client = LspClient(
    rawClient: rawClient,
  );
  await client.start();

  await client.initialize(
    InitializeParams(
      rootUri: 'file://$pwd',
      capabilities: const ClientCapabilities(
        experimental: {
          'supportsDartTextDocumentContentProvider': true,
        },
      ),
    ),
  );

  if (args.verbose) print('CALLING INITIALIZED');
  final initializedFuture = client.initialized();

  if (args.verbose) {
    // ignore: unawaited_futures
    initializedFuture.then((_) {
      print('INITIALIZED COMPLETED');
    });
  }

  if (args.verbose) print('CALLING AWAITANALYZED');
  final analyzedFuture = client.awaitAnalyzed();

  if (args.verbose) {
    // ignore: unawaited_futures
    analyzedFuture.then((_) {
      print('AWAITANALYZED COMPLETED');
    });
  }

  if (args.verbose) print('AWAITING BOTH');
  await (initializedFuture, analyzedFuture).wait;
  if (args.verbose) print('DONE AWAITING');
  // await Future.delayed(const Duration(seconds: 5));

  final contentResult = await client.dartTextDocumentContent(
    DartTextDocumentContentParams(
      uri: 'dart-macro+file://$pwd/${args.path}',
    ),
  );

  String code = contentResult.content;
  if (args.lineNumbers) {
    code = _addLineNumbers(code);
  }

  stdout.write(code);
  await client.dispose();
}

String _addLineNumbers(String str) {
  if (str == '') {
    return '';
  }

  final lines = str.split('\n');

  final maxLineNumber = lines.length;
  final maxDigits = maxLineNumber.toString().length;

  final buffer = StringBuffer();

  for (int i = 0; i < lines.length; i++) {
    // Line numbers start from 1, not 0
    final lineNumber = i + 1;

    // Align right.
    final formattedLineNumber = lineNumber.toString().padLeft(maxDigits);

    buffer.writeln('$formattedLineNumber ${lines[i]}');
  }

  return buffer.toString();
}

_Args _parseArgs(List<String> argv) {
  final parser = ArgParser();

  parser.addOption(
    _fileOption,
    help:
        'The file to show augmentation for, relative to the current directory.',
    mandatory: true,
    valueHelp: 'FILE',
  );

  parser.addFlag(
    _helpFlag,
    help: 'Show this help message.',
    negatable: false,
  );

  parser.addFlag(
    _lineNumbersFlag,
    help: 'Show line numbers.',
    negatable: false,
  );

  parser.addFlag(
    _verboseFlag,
    abbr: _vFlag,
    help: 'Show debug output.',
    negatable: false,
  );

  final result = parser.parse(argv);

  final args = _Args(
    help: result.flag(_helpFlag),
    lineNumbers: result.flag(_lineNumbersFlag),
    path: result.option(_fileOption) ?? '',
    verbose: result.flag(_verboseFlag),
  );

  _validateArgs(args, parser);
  return args;
}

void _validateArgs(_Args args, ArgParser parser) {
  if (args.help) {
    _printUsage(parser);
    exit(0);
  }

  if (args.path == '') {
    _printUsage(parser);
    exit(_usageError);
  }
}

void _printUsage(ArgParser parser) {
  print(
    'Shows augmentation generated by macros for a given file, if any.\n\n'
            'Usage: '
            'dart run show_augmentation --$_fileOption=relative/path/to/file.dart [--$_lineNumbersFlag] [-v]\n' +
        parser.usage,
  );
}

class _Args {
  const _Args({
    required this.help,
    required this.lineNumbers,
    required this.path,
    required this.verbose,
  });

  final bool help;
  final bool lineNumbers;
  final String path;
  final bool verbose;
}
